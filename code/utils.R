messager <- MAGMA.Celltyping:::messager
message_parallel <- MAGMA.Celltyping:::message_parallel


#' Gather metadata for each GWAS dataset
#' 
#' 
#' `MungeSumstats` automatically keeps log files in the `tempdir()`. 
#' But if you restart your R session mid-way, they'll be erased. 
#' Or perhaps you ran `MungeSumstats` without turning on any of the
#'  log arguments.\cr
#' Instead, you can infer the genome build directly from the data. 
#' Note that this will take some time as the genome reference data needed 
#' to make these inferences is quite large.
#' 
#' \strong{IMPORTANT}: Notice that we assign  "munged_path" using a 
#' named list ( `munged_files[metagwas_all$id]`).
#'  This is because `find_sumstats` resorts the results (by sample sizes), 
#'  thus the order is different. Using the named list to extract the
#'   values in the order they appear in the data.table ensures
#'    the data in each column comes from the same GWAS dataset.
#'    
#' @param save_dir Directory in which your munged summary statistics
#'  files (and logs) are saved.
#' @param use_logs Whether to search for and extract info from logs generated by 
#' \pkg{MungeSumstats}.
#' @param infer_builds If "inferred_build" is missing from log data 
#' (or there is no log data to search), you can set \code{infer_builds=TRUE} to
#' infer the genome build of each GWAS.
#' @param save_meta Path to save new metadata file to.
#' @param verbose Print messages.
#' @inheritParams add_1KG_population
#' @inheritParams MungeSumstats::list_sumstats
#' 
#' @export
#' @examples 
#' \dontrun{
#' meta <- gather_metadata(save_dir = save_dir)
#' }
gather_metadata <- function(save_dir, 
                            pattern = "*.tsv.gz$",
                            use_logs = TRUE,
                            infer_builds = FALSE,
                            default_pop="EUR",
                            default_build="GRCH37",
                            N_dict=c("Wightman2021"=1126563,
                                     "Vuckovic2020"=408112),
                            save_meta = here::here("metadata.csv"),
                            verbose = TRUE){
  #### Search for munged GWAS sumstats ####
  munged_files <- MungeSumstats::list_sumstats(save_dir = save_dir,
                                               pattern = pattern,
                                               verbose = verbose)
  munged_files_dt <- data.table::data.table(id=names(munged_files),
                                            munged_path=unname(munged_files))
  #### Query OpenGWAS metadata ####
  metagwas_all <- MungeSumstats::find_sumstats(ids = names(munged_files))
  metagwas_all[,query:=id]
  metagwas_all <- data.table::merge.data.table(
    metagwas_all,
    munged_files_dt,
    by="id", 
    all = TRUE)
  #### Add in log data generated by MungeSumstats ####
  if(use_logs){
    log_data <- MungeSumstats::parse_logs(save_dir = save_dir) 
    #### Merge metadata sources ####
    meta <- merge(metagwas_all, log_data, by = "id", all = TRUE)
  }else {meta <- metagwas_all}
  #### Re-infer genome build ####
  if(isTRUE(infer_builds)){
    builds <- MungeSumstats::get_genome_builds(sumstats_list = munged_files, 
                                               header_only = 10000)
    meta$build_inferred <-  builds[meta$id] 
  }
  #### Find which GWAS have different inferred genome builds #### 
  meta <- check_build_matches(meta = meta,
                              default_build = default_build)
  #### Add GitHub download links to genes.raw and genes.out files #####
  meta <- add_file_links(meta = meta)
  #### Translate populations to match 1KG ref ####
  meta <- add_1KG_population(meta = meta,
                             default_pop = default_pop)
  #### Add missing N #####
  meta <- add_sample_size(meta = meta,
                          N_dict = N_dict)
  #### Save metadata ####
  if(!is.null(save_meta)){
    messager("Saving merged metadata ==>",save_meta,v=verbose)
    MungeSumstats:::unlist_dt(dt = meta)
    data.table::fwrite(meta, save_meta, sep=",")
  } 
  return(meta)
}

add_file_links <- function(meta,
                           gene_files = NULL,
                           user = "neurogenomics",
                           repo = "MAGMA_Files_Public",
                           branch = "master",
                           data_dir = "data/MAGMA_Files",
                           include_local_paths = FALSE,
                           verbose = TRUE){ 
  messager("Adding GitHub download URLs for .genes.raw and .genes.out files.",
           v=verbose)
  base_url <- file.path("https://github.com",user,repo,"raw",branch,data_dir)
  if(is.null(gene_files)){
    gene_files <- list()
    gene_files$genes.raw <- list_snps_to_genes_files(save_dir = data_dir, 
                                                     pattern = ".genes.raw$",
                                                     verbose = verbose)
    gene_files$genes.out <- list_snps_to_genes_files(save_dir = data_dir, 
                                                     pattern = ".genes.out$",
                                                     verbose = verbose)
  }
  
  meta <- meta %>%
    dplyr::mutate(genes_raw_path = 
                    ifelse(meta$id %in% names(gene_files$genes.raw), 
                           as.character(gene_files$genes.raw[meta$id]), NA),
                  genes_out_path = 
                    ifelse(meta$id %in% names(gene_files$genes.out), 
                           as.character(gene_files$genes.out[meta$id]), NA)
    ) %>%
    dplyr::mutate(genes_raw_url = 
                    ifelse(is.na(genes_raw_path),NA,
                           file.path(base_url,
                                     basename(dirname(genes_raw_path)),
                                     basename(genes_raw_path))),
                  genes_out_url = 
                    ifelse(is.na(genes_out_path),NA,
                           file.path(base_url,
                                     basename(dirname(genes_out_path)),
                                     basename(genes_out_path)))
                  )
  if(!include_local_paths){
    meta <- meta %>% dplyr::select(-genes_raw_path, -genes_out_path)
  }
  return(meta)
}


#' Checks whether OpenGWAS and MungeSumstats genome builds match
#'  
#' Creates a new column to examine
#' whether the genome-build  \link[MungeSumstats]{get_genome_builds}
#' inferred from the each GWAS dataset ("build_inferred") matches the
#' build reported by OpenGWAS ("build").
#' 
#' @param meta GWAS metadata.
#' @param verbose Print messages.
#' 
#' @return GWAS metadata.
#' 
#' @importFrom stringr str_split
#' @keywords internal
check_build_matches <- function(meta,
                                default_build="GRCH37",
                                verbose = TRUE){
  build_inferred <- build <- NULL;
  
  for(x in c("build","build_inferred")){
    if(!x %in% colnames(meta)){
      messager("Missing",paste0("'",x,"'"),"column.",
               "Cannot run check_build_matches.",
               v=verbose)
      return(meta)
    } 
  }  
  #### Fill missing builds ####
  na_pops <- is.na(meta$population)
  if(sum(na_pops)>0){
    message(formatC(sum(na_pops),big.mark = ",")," populations are NA.\n",
            "These will be filled with the default_build: ",default_build)
  }
  #### Compare build to build_inferred ####
  meta <- meta |>
    dplyr::mutate(build_matches = (toupper(
      stringr::str_split(build,"/",
                         simplify = TRUE)[,2]
    )==build_inferred) & (!is.na(build)) & (!is.na(build_inferred)) ) 
  #### Summarise ####
  messager(sum(meta$build_matches,na.rm = TRUE),"/",nrow(meta),
          "inferred genome builds match the reported genome build.",
          v=verbose) 
  #### Fill builds where build_inferred is not available ####
  meta$build_matches 
  meta <- dplyr::mutate(
    meta, 
    build_final = dplyr::coalesce(gsub("HG19/GRCh37","GRCH37",build), 
                                  build_inferred)) 
  return(meta)
}

assign_trait_groups <- function(meta,
                                traits,
                                verbose = TRUE){
  messager("Assigning each trait to a trait_group.",v=verbose)
  meta$trait_group <- stringr::str_extract(
    tolower(meta$trait),
    paste0("(",tolower(traits),")",collapse = "|"))
  meta[is.na(meta$trait_group),"trait_group"] <- "other"
  return(meta)
}

filter_traits <- function(meta,
                          traits = NULL,
                          consortia = NULL,
                          startswith_only = FALSE,
                          exclusion_terms = NULL,
                          group_var = "trait_group",
                          topn = Inf,
                          verbose = TRUE){
  ### Assign groups by substring search ####
  if(!is.null(traits)){
    meta <- assign_trait_groups(meta = meta, 
                                traits = traits, 
                                verbose = verbose)
  }
  #### Include only datasets that start with terms #####
  if(startswith_only){
    messager("Removing trait that don't start with search terms.",v=verbose)
    meta <- meta[grepl(paste0("^",traits,collapse = "|"),
                       meta$trait, 
                       ignore.case = TRUE),]
  }
  #### Exclude traits with certain terms ####
  if(!is.null(exclusion_terms)){
    messager("Excluding traits with the terms:",
             paste(exclusion_terms,collapse = ", "),v=verbose)
    meta <- meta[!grepl(paste0(exclusion_terms,collapse = "|"),
                       meta$trait, 
                       ignore.case = TRUE),]
  }
  #### Include only certai consortia ####
  if(!is.null(consortia)){
    messager("Only including datasets from:",
             paste(consortia,collapse = ", "),v=verbose)
    ## Catch UKB datasets that aren't labeled properly in "consortium"
    if("UK Biobank" %in% consortia){
      meta <- subset(meta, consortium %in% consortia | startsWith(id,"ukb"))
    }else {
      meta <- subset(meta, consortium %in% consortia)
    }
  }
  ##### Return only top N datasets ####
  if(!is.infinite(topn)){
    if(group_var %in% colnames(meta)){
      messager("Only including top",topn,"datasets per trait group.",v=verbose)
      meta <- meta %>%
        dplyr::group_by_at(.vars = group_var) %>%
        dplyr::top_n(n = topn, wt = N)
    }else {
      messager("group_var",paste0("'",group_var,"'"),
               "is not a column in the meta.",
               "topn filtering will not be used.",
               v=verbose)
    }
    
  } 
  messager("Returning metadata for",nrow(meta),"GWAS datasets.",v=verbose)
  return(data.table::data.table(meta))
}



#' List SNPs-to-genes mapping files
#' 
#' List paths to all SNPs-to-genes mapping files generated by
#' \link[MAGMA.Celltyping]{map_snps_to_genes}.
#' 
#' @param save_dir Directory to recursively search for matching files in.
#' @inheritParams base::list.files
#' 
#' @return Named list of paths.
#' 
#' @keywords internal
list_snps_to_genes_files <- function(save_dir,
                                     pattern = "*.genes.out$",
                                     verbose = TRUE){
  gene_files <- list.files(path = save_dir, 
                            pattern = pattern,
                            recursive = TRUE, 
                            full.names = TRUE)
  if(length(gene_files)==0) return(NULL)
  # names(gene_files) <- basename(dirname(dirname(dirname(gene_files))))
  names(gene_files) <- stringr::str_split(basename(gene_files),"[.]",
                                          simplify = TRUE)[,1]
  messager(length(gene_files),"files found.",v=verbose)
  return(gene_files)
}


#' Copy MAGMA gene mapping files to new folder
#' 
#' Copy SNPs-to-genes mapping files (\emph{.genes.out}) produced by 
#' \link[MAGMA.Celltyping]{map_snps_to_genes} to a new folder. 
#' Importantly, this function maintains the file naming and folder structure 
#' conventions necessary to run other downstream 
#' \pkg{MAGMA.Celltyping} functions.
#' 
#' @param gene_files Full paths to gene mapping mapping files.
#' @param save_dir Where to save the gene mapping files to.
#' @param overwrite Whether to overwrite gene mapping files that already
#'  exist in \code{save_dir} (Default: \code{FALSE})
#' 
#' @return Named character list
#' 
#' @keywords internal 
copy_snps_to_genes_files <- function(search_dir,
                                     pattern = "*.genes.out$|*.genes.raw$",
                                     save_dir = "MAGMA_Files",
                                     overwrite = FALSE){
  requireNamespace("parallel")
  gene_files <- list_snps_to_genes_files(save_dir = search_dir, 
                                         pattern = pattern)
  gene_files2 <- parallel::mclapply(gene_files, function(x){
    message_parallel(basename(x))
    new_file <- file.path(save_dir,
                          basename(dirname(x)),
                          basename(x))
    if(file.exists(new_file) && overwrite == FALSE){
      message_parallel("Skipping: File already exists.")
      return(new_file)
    } else {
      dir.create(dirname(new_file),
                 showWarnings = FALSE, recursive = TRUE)
      file.copy(x, new_file, overwrite = overwrite)
    }
    return(new_file)
  })
  #### Separate .raw and .out files ####
  genes.raw <- gene_files2[
    unlist(lapply(gene_files2,function(x){endsWith(x,suffix = ".genes.raw")}))]
  genes.out <- gene_files2[
    unlist(lapply(gene_files2,function(x){endsWith(x,suffix = ".genes.out")}))]
  return(list(genes.raw = genes.raw, 
              genes.out = genes.out))
}

#' Translate subpopulations
#'  
#' We need to use the appropriate 1000 Genomes Project (1KG)
#' linkage disequilibrium (LD) reference for each GWAS based on the 
#' subpopulation that the GWAS was conducted
#' in. Here we map the subpopulation names used by OpenGWAS to those used by 1KG.
#' The LD references provided by MAGMA are already subdivided by population, 
#' which means you can't select more than one (or all) subpopulations 
#' as a reference. This is a limitation we would like to address in the future
#' by provided our own LD reference files.
#' @param meta Metadata \link[data.table]{data.table}.
#' @param popdict Population dictionary.
#' @param default_pop Default population when "population" column is missing.
#' @returns metadata \link[data.table]{data.table}
#'  with new column "population_1KG".
#' 
#' @keywords internal
add_1KG_population <- function(
    meta,
    popdict = c("European"="EUR", 
                 "South Asian"="SAS",
                 "African American or Afro-Caribbean"="AFR",
                 "Greater Middle Eastern (Middle Eastern, North African, or Persian)"="EUR",# not ideal
                 "East Asian"="EAS",
                 "Mixed"="AMR", # not ideal
                 "Hispanic or Latin American"="AMR",
                 "Asian unspecified"="EAS", # not ideal
                 "Sub-Saharan African"="AFR",
                 "NA"="EUR", # not ideal
                 "African unspecified"="AFR",
                 "South East Asian"="EAS" # not ideal
    ),
    default_pop="EUR"){
  population <- NULL;
  #### Translate ####
  meta <- dplyr::mutate(meta, 
                population_1KG=ifelse(is.na(population),
                                      default_pop, 
                                      popdict[population])) 
  return(meta)
}

add_sample_size <- function(meta,
                            N_dict=c("Wightman2021"=1126563,
                                     "Vuckovic2020"=408112)){
  if(is.null(N_dict)) return(meta)
  #### Find matching GWAS using substring search ####
  N_dict_filled <- lapply(names(N_dict), function(x){
    nms <- grep(x,meta$id, value = TRUE)
    stats::setNames(rep(N_dict[[x]],length(nms)),nms)
  }) |> unlist()
  #### Fill missing N ####
  if(length(N_dict_filled)>0){
    na_ids <- meta[is.na(meta$N),]$id
    data.table::setkeyv(meta,"id")
    meta[na_ids,]$N <- N_dict_filled[na_ids]
  }
  return(meta)
}

